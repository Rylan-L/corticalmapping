__author__ = 'junz'

import json
import numpy as np
import matplotlib.pyplot as plt
import core.ImageAnalysis as ia
import core.FileTools as ft
import scipy.ndimage as ni


def translateMovieByVasculature(mov,parameterPath,movDecimation,mappingDecimation=2):
    '''

    :param mov: movie before translation (could be 2d (just one frame) or 3d)
    :param parameterPath: path to the json file with translation parameters generated by VasculatureMapMatching GUI
    :param movDecimation: decimation factor from movie vasculature image to movie
    :param mappingDecimation: decimation factor from mapping vasculature image to mapped areas, usually 2
    :return: translated movie
    '''

    with open(parameterPath) as f:
        matchingParams = json.load(f)

    movDecimation = float(movDecimation); mappingDecimation=float(mappingDecimation)

    if matchingParams['Xoffset']%movDecimation != 0: print 'Original Xoffset is not divisble by movDecimation. Taking the floor integer.'
    if matchingParams['Yoffset']%movDecimation != 0: print 'Original Yoffset is not divisble by movDecimation. Taking the floor integer.'

    offset =  [int(matchingParams['Xoffset']/movDecimation),
               int(matchingParams['Yoffset']/movDecimation)]

    if matchingParams['ReferenceMapHeight']%movDecimation != 0: print 'Original ReferenceMapHeight is not divisble by movDecimation. Taking the floor integer.'
    if matchingParams['ReferenceMapWidth']%movDecimation != 0: print 'Original ReferenceMapWidth is not divisble by movDecimation. Taking the floor integer.'

    outputShape = [int(matchingParams['ReferenceMapHeight']/movDecimation),
                   int(matchingParams['ReferenceMapHeight']/movDecimation)]

    movT = ia.rigidTransform_cv2(mov,zoom=matchingParams['Zoom'],rotation=matchingParams['Rotation'],offset=offset,outputShape=outputShape)

    if mappingDecimation/movDecimation != 1:
        movT = ia.rigidTransform_cv2(movT, zoom=mappingDecimation/movDecimation)

    print 'shape of output movie:', movT.shape

    return movT


def segmentMappingPhotodiodeSignal(pd,digitizeThr=1.,filterSize=0.005,segmentThr=0.04,Fs=10000.):
    '''

    :param pd: photodiode from mapping jphys file
    :param digitizeThr: threshold to digitize photodiode readings
    :param filterSize: gaussian filter size to filter photodiode signal, sec
    :param segmentThr: threshold to detect the onset of each stimulus sweep
    :param Fs: sampling rate
    :return:
    '''

    pd[pd<digitizeThr] = 0.; pd[pd>=digitizeThr] = 5.

    filterDataPoint = int(filterSize*Fs)

    pdFiltered = ni.filters.gaussian_filter(pd, filterDataPoint)
    pdFilteredDiff = np.diff(pdFiltered)
    pdFilteredDiff = np.hstack(([0],pdFilteredDiff))
    pdSignal = np.multiply(pd, pdFilteredDiff)

    displayOnsets = []

    for i in range(1,len(pdSignal)):
        if pdSignal[i] > segmentThr and pdSignal[i-1]  < segmentThr:
            displayOnsets.append(i * (1. / Fs))

    displayOnsets = np.array(displayOnsets)

    print 'Number of presentation:', len(displayOnsets)
    print 'Display onsets (sec):',displayOnsets

    return displayOnsets




if __name__ == '__main__':

    #===========================================================================
    jphysPath = r"\\aibsdata2\nc-ophys\CorticalMapping\IntrinsicImageData\150901-M177931\150901JPhys103"
    _, jphys = ft.importRawNewJPhys(jphysPath)
    pd = jphys['photodiode']
    displayOnsets = segmentMappingPhotodiodeSignal(pd)
    #===========================================================================

    print 'for debug...'

